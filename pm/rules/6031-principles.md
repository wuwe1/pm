# MIT 6.031 软件构造核心原则

本规则定义了贯穿 PM 全流程的软件工程原则，源自 MIT 6.031 Software Construction。

## 三大目标

所有代码必须同时满足以下三个目标：

### 1. Safe from bugs（远离缺陷）

- 静态类型检查，编译期捕获错误
- 全面的测试覆盖（等价类划分 + 边界值）
- 优先使用不可变数据结构
- 清晰的函数规范（前置条件 + 后置条件）

### 2. Easy to understand（易于理解）

- 类型声明即文档
- 规范注释（`@param`、`@returns`、`@throws`）
- 有意义的命名（变量用名词，函数用动词）
- 一致的代码风格

### 3. Ready for change（适应变化）

- 模块化设计，低耦合
- 抽象数据类型（ADT）封装实现
- 避免硬编码，使用命名常量
- 表示独立性：内部实现可替换，客户端无感知

## 规范即契约（Specification as Contract）

函数是实现者与调用者之间的契约：

- **前置条件（Precondition）**：调用者的义务，调用前必须为真
- **后置条件（Postcondition）**：实现者的保证，调用后必定为真

```
前置条件成立 → 后置条件必须成立
前置条件不成立 → 实现者无义务（可做任何事）
```

### 规范的应用

- PRD 的 User Stories 应包含前置条件和后置条件
- API 设计应明确定义每个接口的契约
- 测试用例应验证契约的两端

## 测试优先（Test-First Programming）

流程：**规范 → 测试 → 实现**

### 等价类划分

将输入空间分为若干子域，每个子域中的输入预期产生相似行为：

1. 按照规范划分输入空间
2. 子域之间不相交，并集覆盖全部输入
3. 每个子域选一个代表值作为测试用例

### 边界值测试

在子域的边界上选择测试用例：

- 数值：0、1、-1、MAX、MIN
- 集合：空集、单元素、满容量
- 字符串：空串、单字符、超长字符串

### 回归测试

发现 bug 时：

1. 先写一个能暴露 bug 的测试
2. 确认测试失败
3. 修复 bug
4. 确认测试通过
5. 测试永久保留

## 抽象数据类型（ADT）

### 操作四分类

| 类型 | 定义 | 示例 |
|------|------|------|
| **Creator** | 创建新对象，不需要已有实例 | 构造函数、工厂方法 |
| **Producer** | 从已有实例生成新实例 | `concat()`、`slice()` |
| **Observer** | 返回对象信息，不修改状态 | `length`、`get()` |
| **Mutator** | 修改对象状态 | `push()`、`set()` |

### 表示独立性

- 客户端仅依赖公开操作的规范
- 不依赖私有字段
- 内部表示可替换，客户端代码无需修改

### 设计原则

1. **简洁性**：少数简单操作可组合成强大功能
2. **一致性**：每个操作有明确目的
3. **充分性**：提供足够操作提取任何属性
4. **优先不可变**：不可变 ADT 更安全、更易推理

## 表示不变量（RI）与抽象函数（AF）

### 表示不变量 RI

布尔条件，定义内部表示的合法状态：

```
RI : R → boolean
RI(r) = true  → r 是合法表示
RI(r) = false → r 是非法表示
```

### 抽象函数 AF

从具体表示到抽象值的映射：

```
AF : R → A
多个表示值可映射到同一抽象值
```

### checkRep

在每个公开方法的开头和结尾调用 `checkRep()` 验证 RI：

- Creator / Producer / Mutator：**必须**调用
- Observer：建议调用（捕捉表示暴露导致的破坏）
- 防止表示暴露：不返回内部可变对象的引用

## 代码审查检查清单

| 检查项 | 说明 |
|--------|------|
| 魔法数字 | 用命名常量替代硬编码数值 |
| DRY | 相似逻辑提取为函数或循环 |
| 变量复用 | 一个变量只有一个用途 |
| 全局变量 | 转为参数 / 返回值 |
| 快速失败 | 尽早检测错误，不让非法状态传播 |
| 命名规范 | 变量名词、函数动词、常量全大写 |
| 注释质量 | 解释"为什么"而非"做什么" |
